import numpy as np

class CBF_Formulation:
    """
    Module 4: CR-CBF (Conformally Robust Safety).
    Implements Super-Ellipsoid Safe Set with Uncertainty Margins.
    Reference: Agrawal et al. (CR-CBF) & Ames et al. (HO-CBF)
    """
    def __init__(self, center, lengths, power_n=4, q_cp=0.0):
        self.xc = np.array(center)
        self.n = int(power_n)
        self.q_cp = q_cp  # Conformal Quantile (Risk Parameter)
        
        # Matrix A setup: h(x) = 1 - sum((delta/r)^(2n))
        # Stored as diagonal matrix for vectorized math
        self.dims = np.array(lengths)
        self.A_diag = 1.0 / (self.dims ** (2 * self.n))
        self.A = np.diag(self.A_diag)

        # --- OPTIMIZED TUNING: Pole Placement ---
        # Critical Damping at eigenvalue -30.0
        p0 = 30.0
        p1 = 30.0
        
        self.k1 = p0 + p1  # 60.0 (Damping)
        self.k0 = p0 * p1  # 900.0 (Stiffness)

    def get_h(self, x):
        """ Barrier Value h(x) """
        diff = x - self.xc
        abs_diff_n = np.abs(diff) ** self.n
        # h = 1 - y^T A y where y = |x-xc|^n
        term = abs_diff_n.T @ self.A @ abs_diff_n
        return 1.0 - term

    def get_h_dot(self, x, dx):
        """ Time Derivative h_dot(x) """
        diff = x - self.xc
        sign_diff = np.sign(diff)
        
        # Chain rule term: d(|x|^n)/dx = n * |x|^(n-1) * sign(x)
        pow_n_1 = np.abs(diff) ** (self.n - 1)
        X_tilde = sign_diff * self.n * pow_n_1 * dx 
        
        # Original term y = |x|^n
        term_abs_n = np.abs(diff) ** self.n
        
        # h_dot = -2 * y^T * A * y_dot
        h_dot = -2 * term_abs_n.T @ self.A @ X_tilde
        return h_dot, X_tilde

    def get_constraints(self, x, dx, a_des):
        """
        Returns Linear Constraints for QP: cbf_L * mu >= cbf_b
        
        Args:
            x: Current position
            dx: Current velocity
            a_des: The Nominal Acceleration (PD + Feedforward)
                   This is crucial because mu is a *correction* to a_des.
        """
        h_val = self.get_h(x)
        h_dot, X_tilde = self.get_h_dot(x, dx)
        
        # --- Calculate Second Derivative Terms (h_ddot) ---
        diff = x - self.xc
        sign_diff = np.sign(diff)
        term_abs_n = np.abs(diff) ** self.n
        
        # 1. Drift Terms (parts of h_ddot not depending on acceleration)
        pow_n_2 = np.abs(diff) ** (self.n - 2)
        
        # Second derivative of the inner power term
        dX_tilde_drift = self.n * (self.n - 1) * pow_n_2 * (dx * dx)
        
        term1 = -2 * X_tilde.T @ self.A @ X_tilde
        h_ddot_drift = term1 - 2 * term_abs_n.T @ self.A @ dX_tilde_drift
        
        # 2. Gradient w.r.t Acceleration (Control Influence)
        pow_n_1 = np.abs(diff) ** (self.n - 1)
        dX_tilde_acc_coeff = self.n * sign_diff * pow_n_1
        
        # LgLfh (Lie Derivative w.r.t input)
        grad_x_ddot = -2 * term_abs_n.T @ self.A @ np.diag(dX_tilde_acc_coeff)
        
        # --- Robustness (CR-CBF) ---
        # "Tighten" the constraint based on the gradient norm and quantile q_cp
        norm_grad = np.linalg.norm(grad_x_ddot)
        robust_margin = norm_grad * self.q_cp
        
        # --- Formulate QP Constraint ---
        # Original: h_ddot + k1*h_dot + k0*h >= 0
        # Expand:   Drift + Grad*(a_des + mu) + k1*h_dot + k0*h >= 0
        # Rearrange for mu: 
        # Grad * mu >= -Drift - Grad*a_des - k1*h_dot - k0*h + robust_margin
        
        cbf_L = grad_x_ddot
        
        cbf_b = (-h_ddot_drift 
                 - (grad_x_ddot @ a_des) 
                 - self.k1*h_dot 
                 - self.k0*h_val 
                 + robust_margin) 
        
        # Reshape to (1, 3) and (1,) for scipy solver compatibility
        return cbf_L.reshape(1, -1), np.array([cbf_b])